{"version":3,"file":"firesql.umd.js","sources":["../src/sql-parser/index.js","../src/utils.ts","../src/select/groupby.ts","../src/select/where.ts","../src/select/index.ts","../src/select/orderby.ts","../src/select/limit.ts","../src/firesql.ts","../node_modules/core-js/internals/fails.js","../node_modules/core-js/internals/to-indexed-object.js","../node_modules/core-js/internals/require-object-coercible.js","../node_modules/core-js/internals/to-integer.js","../node_modules/core-js/internals/array-includes.js","../node_modules/core-js/internals/to-absolute-index.js","../node_modules/core-js/internals/to-length.js","../node_modules/core-js/internals/create-property-descriptor.js","../node_modules/core-js/internals/is-object.js","../node_modules/core-js/internals/to-primitive.js","../node_modules/core-js/internals/has.js","../node_modules/core-js/internals/document-create-element.js","../node_modules/core-js/internals/an-object.js","../src/rx/index.ts","../node_modules/core-js/internals/classof-raw.js","../node_modules/core-js/internals/indexed-object.js","../node_modules/core-js/internals/global.js","../node_modules/core-js/internals/descriptors.js","../node_modules/core-js/internals/object-property-is-enumerable.js","../node_modules/core-js/internals/ie8-dom-define.js","../node_modules/core-js/internals/object-get-own-property-descriptor.js","../node_modules/core-js/internals/object-define-property.js","../node_modules/core-js/internals/hide.js","../node_modules/core-js/internals/set-global.js","../node_modules/core-js/internals/uid.js","../node_modules/core-js/internals/shared-key.js","../node_modules/core-js/internals/internal-state.js","../node_modules/core-js/internals/shared.js","../node_modules/core-js/internals/function-to-string.js","../node_modules/core-js/internals/native-weak-map.js","../node_modules/core-js/internals/hidden-keys.js","../node_modules/core-js/internals/object-keys-internal.js","../node_modules/core-js/internals/copy-constructor-properties.js","../node_modules/core-js/internals/is-forced.js","../node_modules/core-js/internals/export.js","../node_modules/core-js/internals/object-create.js","../node_modules/core-js/internals/redefine.js","../node_modules/core-js/internals/enum-bug-keys.js","../node_modules/core-js/internals/object-get-own-property-names.js","../node_modules/core-js/internals/object-get-own-property-symbols.js","../node_modules/core-js/internals/own-keys.js","../node_modules/core-js/internals/native-symbol.js","../node_modules/core-js/internals/well-known-symbol.js","../node_modules/core-js/internals/object-keys.js","../node_modules/core-js/internals/object-define-properties.js","../node_modules/core-js/internals/html.js","../node_modules/core-js/internals/add-to-unscopables.js","../node_modules/core-js/internals/bind-context.js","../node_modules/core-js/modules/es.array.includes.js","../node_modules/core-js/internals/entry-unbind.js","../node_modules/core-js/internals/a-function.js","../node_modules/core-js/modules/es.number.is-nan.js","../node_modules/core-js/internals/path.js","../node_modules/core-js/es/number/is-nan.js"],"sourcesContent":["// Generated by PEG.js v0.11.0-master.30f3260, https://pegjs.org/\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n\n  // istanbul ignore next\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    },\n\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n\n  var peg$startRuleFunctions = { start: peg$parsestart };\n  var peg$startRuleFunction = peg$parsestart;\n\n  var peg$c0 = \"(\";\n  var peg$c1 = \")\";\n  var peg$c2 = \"`\";\nvar peg$c3 = \"/\";\nvar peg$c4 = \"!\";\nvar peg$c5 = \"=\";\nvar peg$c6 = \">=\";\nvar peg$c7 = \">\";\nvar peg$c8 = \"<=\";\nvar peg$c9 = \"<>\";\nvar peg$c10 = \"<\";\nvar peg$c11 = \"!=\";\nvar peg$c12 = \"+\";\nvar peg$c13 = \"-\";\nvar peg$c14 = \"*\";\nvar peg$c15 = \"%\";\nvar peg$c16 = \"\\\"\";\nvar peg$c17 = \"'\";\nvar peg$c18 = \"\\\\'\";\nvar peg$c19 = \"\\\\\\\"\";\nvar peg$c20 = \"\\\\\\\\\";\nvar peg$c21 = \"\\\\/\";\nvar peg$c22 = \"\\\\b\";\nvar peg$c23 = \"\\\\f\";\nvar peg$c24 = \"\\\\n\";\nvar peg$c25 = \"\\\\r\";\nvar peg$c26 = \"\\\\t\";\nvar peg$c27 = \"\\\\u\";\nvar peg$c28 = \".\";\nvar peg$c29 = \"null\";\nvar peg$c30 = \"true\";\nvar peg$c31 = \"false\";\nvar peg$c32 = \"show\";\nvar peg$c33 = \"select\";\nvar peg$c34 = \"from\";\nvar peg$c35 = \"as\";\nvar peg$c36 = \"table\";\nvar peg$c37 = \"union\";\nvar peg$c38 = \"if\";\nvar peg$c39 = \"exists\";\nvar peg$c40 = \"where\";\nvar peg$c41 = \"group\";\nvar peg$c42 = \"by\";\nvar peg$c43 = \"order\";\nvar peg$c44 = \"limit\";\nvar peg$c45 = \"asc\";\nvar peg$c46 = \"desc\";\nvar peg$c47 = \"all\";\nvar peg$c48 = \"distinct\";\nvar peg$c49 = \"between\";\nvar peg$c50 = \"in\";\nvar peg$c51 = \"is\";\nvar peg$c52 = \"like\";\nvar peg$c53 = \"contains\";\nvar peg$c54 = \"not\";\nvar peg$c55 = \"and\";\nvar peg$c56 = \"or\";\nvar peg$c57 = \"count\";\nvar peg$c58 = \"max\";\nvar peg$c59 = \"min\";\nvar peg$c60 = \"sum\";\nvar peg$c61 = \"avg\";\nvar peg$c62 = \",\";\n\nvar peg$r0 = /^[^`]/;\n  var peg$r1 = /^[A-Za-z_]/;\n  var peg$r2 = /^[A-Za-z0-9_]/;\n  var peg$r3 = /^[^'\\\\\\0-\\x1F\\x7F]/;\n  var peg$r4 = /^[^\"\\\\\\0-\\x1F\\x7F]/;\n  var peg$r5 = /^[\\n\\r]/;\n  var peg$r6 = /^[0-9]/;\n  var peg$r7 = /^[1-9]/;\n  var peg$r8 = /^[0-9a-fA-F]/;\n  var peg$r9 = /^[eE]/;\n  var peg$r10 = /^[+\\-]/;\n  var peg$r11 = /^[ \\t\\n\\r]/;\n\n  var peg$e0 = peg$literalExpectation(\"(\", false);\n  var peg$e1 = peg$literalExpectation(\")\", false);\n  var peg$e2 = peg$otherExpectation(\"column_clause\");\n  var peg$e3 = peg$literalExpectation(\"`\", false);\nvar peg$e4 = peg$literalExpectation(\"/\", false);\nvar peg$e5 = peg$literalExpectation(\"!\", false);\nvar peg$e6 = peg$literalExpectation(\"=\", false);\nvar peg$e7 = peg$literalExpectation(\">=\", false);\nvar peg$e8 = peg$literalExpectation(\">\", false);\nvar peg$e9 = peg$literalExpectation(\"<=\", false);\nvar peg$e10 = peg$literalExpectation(\"<>\", false);\nvar peg$e11 = peg$literalExpectation(\"<\", false);\nvar peg$e12 = peg$literalExpectation(\"!=\", false);\nvar peg$e13 = peg$literalExpectation(\"+\", false);\nvar peg$e14 = peg$literalExpectation(\"-\", false);\nvar peg$e15 = peg$literalExpectation(\"*\", false);\nvar peg$e16 = peg$literalExpectation(\"%\", false);\nvar peg$e17 = peg$classExpectation([\"`\"], true, false);\n  var peg$e18 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"], \"_\"], false, false);\n  var peg$e19 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"], [\"0\", \"9\"], \"_\"], false, false);\n  var peg$e20 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e21 = peg$literalExpectation(\"'\", false);\n  var peg$e22 = peg$classExpectation([\"'\", \"\\\\\", [\"\\0\", \"\\x1F\"], \"\\x7F\"], true, false);\n  var peg$e23 = peg$classExpectation([\"\\\"\", \"\\\\\", [\"\\0\", \"\\x1F\"], \"\\x7F\"], true, false);\n  var peg$e24 = peg$literalExpectation(\"\\\\'\", false);\n  var peg$e25 = peg$literalExpectation(\"\\\\\\\"\", false);\n  var peg$e26 = peg$literalExpectation(\"\\\\\\\\\", false);\n  var peg$e27 = peg$literalExpectation(\"\\\\/\", false);\n  var peg$e28 = peg$literalExpectation(\"\\\\b\", false);\n  var peg$e29 = peg$literalExpectation(\"\\\\f\", false);\n  var peg$e30 = peg$literalExpectation(\"\\\\n\", false);\n  var peg$e31 = peg$literalExpectation(\"\\\\r\", false);\n  var peg$e32 = peg$literalExpectation(\"\\\\t\", false);\n  var peg$e33 = peg$literalExpectation(\"\\\\u\", false);\n  var peg$e34 = peg$otherExpectation(\"LITERAL INT\");\n  var peg$e35 = peg$literalExpectation(\".\", false);\n  var peg$e36 = peg$otherExpectation(\"NUMBER\");\n  var peg$e37 = peg$otherExpectation(\"HEX\");\n  var peg$e38 = peg$classExpectation([\"e\", \"E\"], false, false);\n  var peg$e39 = peg$classExpectation([\"+\", \"-\"], false, false);\n  var peg$e40 = peg$literalExpectation(\"NULL\", true);\n  var peg$e41 = peg$literalExpectation(\"TRUE\", true);\n  var peg$e42 = peg$literalExpectation(\"FALSE\", true);\n  var peg$e43 = peg$literalExpectation(\"SELECT\", true);\n  var peg$e44 = peg$literalExpectation(\"FROM\", true);\n  var peg$e45 = peg$literalExpectation(\"AS\", true);\n  var peg$e46 = peg$literalExpectation(\"UNION\", true);\n  var peg$e47 = peg$literalExpectation(\"WHERE\", true);\n  var peg$e48 = peg$literalExpectation(\"GROUP\", true);\n  var peg$e49 = peg$literalExpectation(\"BY\", true);\n  var peg$e50 = peg$literalExpectation(\"ORDER\", true);\n  var peg$e51 = peg$literalExpectation(\"LIMIT\", true);\n  var peg$e52 = peg$literalExpectation(\"ASC\", true);\n  var peg$e53 = peg$literalExpectation(\"DESC\", true);\n  var peg$e54 = peg$literalExpectation(\"DISTINCT\", true);\n  var peg$e55 = peg$literalExpectation(\"BETWEEN\", true);\n  var peg$e56 = peg$literalExpectation(\"IN\", true);\n  var peg$e57 = peg$literalExpectation(\"IS\", true);\n  var peg$e58 = peg$literalExpectation(\"LIKE\", true);\n  var peg$e59 = peg$literalExpectation(\"CONTAINS\", true);\n  var peg$e60 = peg$literalExpectation(\"NOT\", true);\n  var peg$e61 = peg$literalExpectation(\"AND\", true);\n  var peg$e62 = peg$literalExpectation(\"OR\", true);\n  var peg$e63 = peg$literalExpectation(\"MAX\", true);\n  var peg$e64 = peg$literalExpectation(\"MIN\", true);\n  var peg$e65 = peg$literalExpectation(\"SUM\", true);\n  var peg$e66 = peg$literalExpectation(\"AVG\", true);\n  var peg$e67 = peg$literalExpectation(\",\", false);\n  var peg$e68 = peg$otherExpectation(\"WHITE_SPACE\");\n\n  var peg$f0 = function(ast) {\n        return ast;\n      };\n  var peg$f1 = function(head, tail) {\n        var cur = head;\n        for (var i = 0; i < tail.length; i++) {\n          cur._next = tail[i][3];\n          cur = cur._next\n        }\n        return head;\n      };\n  var peg$f2 = function(s) {\n        return s[2];\n      };\n  var peg$f3 = function(d, c, f, w, g, o, l) {\n        return {\n          type      : 'select',\n          distinct  : d,\n          columns   : c,\n          from      : f,\n          where     : w,\n          groupby   : g,\n          orderby   : o,\n          limit     : l\n        }\n    };\n  var peg$f4 = function() {\n        return '*';\n      };\n  var peg$f5 = function(head, tail) {\n        return createList(head, tail);\n      };\n  var peg$f6 = function(e, alias) {\n        return {\n          expr : e,\n          as : alias\n        };\n      };\n  var peg$f7 = function(i) { return i; };\n  var peg$f8 = function(l) { return l; };\n  var peg$f9 = function(group, t, alias) {\n        return {\n          db: t.db,\n          parts: (Array.isArray(t) ? t[1] : t).parts,\n          as: alias,\n          group: group ? true : false\n        }\n      };\n  var peg$f10 = function(dt) {\n        return {\n          parts: dt.map(function(parts) { return parts[1]; })\n        }\n      };\n  var peg$f11 = function(e) { return e; };\n  var peg$f12 = function(e, d) {\n      var obj = {\n        expr : e,\n        type : 'ASC'\n      }\n      if (d == 'DESC') {\n        obj.type = 'DESC';\n      }\n      return obj;\n    };\n  var peg$f13 = function(lim) {\n        return lim;\n      };\n  var peg$f14 = function(head, tail) {\n        var el = {\n          type : 'expr_list',\n          value: undefined\n        }\n\n        var l = createExprList(head, tail, el);\n\n        el.value = l;\n        return el;\n      };\n  var peg$f15 = function(head, tail) {\n        return createBinaryExprChain(head, tail);\n      };\n  var peg$f16 = function(expr) {\n        return createUnaryExpr('NOT', expr);\n      };\n  var peg$f17 = function(left, rh) {\n        if (!rh) {\n          return left;\n        } else {\n          var res = null;\n          if (rh.type == 'arithmetic') {\n            res = createBinaryExprChain(left, rh.tail);\n          } else {\n            res = createBinaryExpr(rh.op, left, rh.right);\n          }\n          return res;\n        }\n      };\n  var peg$f18 = function(l) {\n        return {\n          type : 'arithmetic',\n          tail : l\n        }\n      };\n  var peg$f19 = function(op, right) {\n        return {\n          op    : op,\n          right : right\n        }\n      };\n  var peg$f20 = function(op, begin, end) {\n        return {\n          op    : op,\n          right : {\n            type : 'expr_list',\n            value : [begin, end]\n          }\n        }\n      };\n  var peg$f21 = function(nk) { return nk[0] + ' ' + nk[2]; };\n  var peg$f22 = function(op, l) {\n        return {\n          op    : op,\n          right : l\n        }\n      };\n  var peg$f23 = function(head, tail) {\n        return createBinaryExprChain(head, tail)\n      };\n  var peg$f24 = function(e) {\n        e.paren = true;\n        return e;\n      };\n  var peg$f25 = function(tbl, col) {\n        return {\n          type  : 'column_ref',\n          table : tbl,\n          column : col\n        };\n      };\n  var peg$f26 = function(col) {\n        return {\n          type  : 'column_ref',\n          table : '',\n          column: col\n        };\n      };\n  var peg$f27 = function(name) { return reservedMap[name.toUpperCase()] === true; };\n  var peg$f28 = function(name) {\n      return name;\n    };\n  var peg$f29 = function(chars) {\n      return chars.join('');\n    };\n  var peg$f30 = function(parts) { return parts.join(''); };\n  var peg$f31 = function(name, f) {\n        return {\n          type : 'aggr_func',\n          name : name,\n          field: f\n        }\n      };\n  var peg$f32 = function(w) {\n      return w;\n    };\n  var peg$f33 = function() {\n        return {\n          type  : 'star',\n          value : '*'\n        }\n      };\n  var peg$f34 = function() {\n        return {\n          type  : 'null',\n          value : null\n        };\n      };\n  var peg$f35 = function() {\n        return {\n          type  : 'bool',\n          value : true\n        };\n      };\n  var peg$f36 = function() {\n        return {\n          type  : 'bool',\n          value : false\n        };\n      };\n  var peg$f37 = function(ca) {\n        return {\n          type  : 'string',\n          value : ca[1].join('')\n        }\n      };\n  var peg$f38 = function() { return \"'\";  };\n  var peg$f39 = function() { return '\"';  };\n  var peg$f40 = function() { return \"\\\\\"; };\n  var peg$f41 = function() { return \"/\";  };\n  var peg$f42 = function() { return \"\\b\"; };\n  var peg$f43 = function() { return \"\\f\"; };\n  var peg$f44 = function() { return \"\\n\"; };\n  var peg$f45 = function() { return \"\\r\"; };\n  var peg$f46 = function() { return \"\\t\"; };\n  var peg$f47 = function(h1, h2, h3, h4) {\n        return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n      };\n  var peg$f48 = function(n) {\n        return {\n          type  : 'number',\n          value : n\n        }\n      };\n  var peg$f49 = function(n) {\n      return {\n        type: 'number',\n        value: n\n      }\n    };\n  var peg$f50 = function(int_, frac, exp) { var x = parseFloat(int_ + frac + exp); return (x % 1 != 0) ? x.toString() : x.toString() + \".0\"};\n  var peg$f51 = function(int_, frac) { var x = parseFloat(int_ + frac); return (x % 1 != 0) ? x.toString() : x.toString() + \".0\"};\n  var peg$f52 = function(int_, exp) { return parseFloat(int_ + exp).toString(); };\n  var peg$f53 = function(int_) { return parseFloat(int_).toString(); };\n  var peg$f54 = function(digit19, digits) { return digit19 + digits;       };\n  var peg$f55 = function(op, digit19, digits) { return \"-\" + digit19 + digits; };\n  var peg$f56 = function(op, digit) { return \"-\" + digit;            };\n  var peg$f57 = function(digits) { return \".\" + digits; };\n  var peg$f58 = function(e, digits) { return e + digits; };\n  var peg$f59 = function(digits) { return digits.join(\"\"); };\n  var peg$f60 = function(e, sign) { return e + sign; };\n  var peg$f61 = function() { return 'ASC';     };\n  var peg$f62 = function() { return 'DESC';    };\n  var peg$f63 = function() { return 'ALL';     };\n  var peg$f64 = function() { return 'DISTINCT';};\n  var peg$f65 = function() { return 'BETWEEN'; };\n  var peg$f66 = function() { return 'IN';      };\n  var peg$f67 = function() { return 'IS';      };\n  var peg$f68 = function() { return 'LIKE';    };\n  var peg$f69 = function() { return 'CONTAINS';};\n  var peg$f70 = function() { return 'NOT';     };\n  var peg$f71 = function() { return 'AND';     };\n  var peg$f72 = function() { return 'OR';      };\n  var peg$f73 = function() { return 'COUNT';   };\n  var peg$f74 = function() { return 'MAX';     };\n  var peg$f75 = function() { return 'MIN';     };\n  var peg$f76 = function() { return 'SUM';     };\n  var peg$f77 = function() { return 'AVG';     };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return [peg$savedPos, peg$currPos];\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n\n    if ( peg$VALIDFILENAME ) loc.filename = options.filename;\n\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n\n    return loc;\n  }\n\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n\n  function peg$expect(expected) {\n    var top = peg$expected[peg$expected.length - 1];\n\n    if (peg$currPos < top.pos) { return; }\n\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n\n    top.variants.push(expected);\n  }\n\n  function peg$end(invert) {\n    var expected = peg$expected.pop();\n    var top = peg$expected[peg$expected.length - 1];\n    var variants = expected.variants;\n\n    if (top.pos !== expected.pos) { return; }\n\n    if (invert) {\n      variants = variants.map(function(e) {\n        return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n      });\n    }\n\n    Array.prototype.push.apply(top.variants, variants);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$buildError() {\n    var expected = peg$expected[0];\n    var failPos = expected.pos;\n\n    return peg$buildStructuredError(\n      expected.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length\n        ? peg$computeLocation(failPos, failPos + 1)\n        : peg$computeLocation(failPos, failPos)\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    s2 = peg$parseunion_stmt();\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f0(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseunion_stmt() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseselect_stmt();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseKW_UNION();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseselect_stmt();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseKW_UNION();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseselect_stmt();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseselect_stmt() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseselect_stmt_nake();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      rule$expects(peg$e0);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c0;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        s4 = peg$parseselect_stmt();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse__();\n          rule$expects(peg$e1);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s6 = peg$c1;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s2 = [s2, s3, s4, s5, s6];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f2(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseselect_stmt_nake() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_SELECT();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseKW_DISTINCT();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s4 = peg$parse__();\n      s5 = peg$parsecolumn_clause();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parsefrom_clause();\n        if (s7 === peg$FAILED) {\n          s7 = null;\n        }\n        s8 = peg$parse__();\n        s9 = peg$parsewhere_clause();\n        if (s9 === peg$FAILED) {\n          s9 = null;\n        }\n        s10 = peg$parse__();\n        s11 = peg$parsegroup_by_clause();\n        if (s11 === peg$FAILED) {\n          s11 = null;\n        }\n        s12 = peg$parse__();\n        s13 = peg$parseorder_by_clause();\n        if (s13 === peg$FAILED) {\n          s13 = null;\n        }\n        s14 = peg$parse__();\n        s15 = peg$parselimit_clause();\n        if (s15 === peg$FAILED) {\n          s15 = null;\n        }\n        s16 = peg$parse__();\n        peg$savedPos = s0;\n        s0 = peg$f3(s3, s5, s7, s9, s11, s13, s15);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn_clause() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e2);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseKW_ALL();\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parseSTAR();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$begin();\n        s4 = peg$parseident_start();\n        peg$end(true);\n        if (s4 === peg$FAILED) {\n          s3 = undefined;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f4();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecolumn_list_item();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parsecolumn_list_item();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse__();\n          s5 = peg$parseCOMMA();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse__();\n            s7 = peg$parsecolumn_list_item();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        peg$savedPos = s0;\n        s0 = peg$f5(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parsecolumn_list_item() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseadditive_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parsealias_clause();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f6(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsealias_clause() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_AS();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parse__();\n    s3 = peg$parseident();\n    if (s3 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f7(s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefrom_clause() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_FROM();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parsetable_base();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f8(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetable_base() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseKW_GROUP();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = peg$parsetable_name();\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      rule$expects(peg$e3);\n      if (input.charCodeAt(peg$currPos) === 96) {\n        s3 = peg$c2;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsetable_name();\n        if (s4 !== peg$FAILED) {\n          rule$expects(peg$e3);\n          if (input.charCodeAt(peg$currPos) === 96) {\n            s5 = peg$c2;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseKW_AS();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      s5 = peg$parse__();\n      s6 = peg$parseident();\n      if (s6 === peg$FAILED) {\n        s6 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f9(s1, s2, s6);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetable_name() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    rule$expects(peg$e4);\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s3 = peg$c3;\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = peg$parseident_name();\n    if (s4 !== peg$FAILED) {\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        rule$expects(peg$e4);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s3 = peg$c3;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$parseident_name();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f10(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewhere_clause() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_WHERE();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseor_expr();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsegroup_by_clause() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_GROUP();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseKW_BY();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parsecolumn_ref_list();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn_ref_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolumn_ref();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseCOMMA();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parsecolumn_ref();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parsecolumn_ref();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseorder_by_clause() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_ORDER();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseKW_BY();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseorder_by_list();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseorder_by_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseorder_by_element();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseCOMMA();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseorder_by_element();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseorder_by_element();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseorder_by_element() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseor_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseKW_DESC();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseKW_ASC();\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f12(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselimit_clause() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_LIMIT();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseliteral_int();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseexpr_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseor_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseCOMMA();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseor_expr();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseor_expr();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f14(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseor_expr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseand_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseKW_OR();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseand_expr();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseKW_OR();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseand_expr();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f15(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseand_expr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsenot_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseKW_AND();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parsenot_expr();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseKW_AND();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parsenot_expr();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f15(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenot_expr() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_NOT();\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      rule$expects(peg$e5);\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s2 = peg$c4;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$begin();\n        rule$expects(peg$e6);\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s4 = peg$c5;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n        peg$end(true);\n        if (s4 === peg$FAILED) {\n          s3 = undefined;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parsenot_expr();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f16(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsecomparison_expr();\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomparison_expr() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseadditive_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parsecomparison_op_right();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f17(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomparison_op_right() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parsearithmetic_op_right();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsein_op_right();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebetween_op_right();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseis_op_right();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parselike_op_right();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsecontains_op_right();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsearithmetic_op_right() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parse__();\n    s4 = peg$parsearithmetic_comparison_operator();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parse__();\n      s6 = peg$parseadditive_expr();\n      if (s6 !== peg$FAILED) {\n        s3 = [s3, s4, s5, s6];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parse__();\n        s4 = peg$parsearithmetic_comparison_operator();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse__();\n          s6 = peg$parseadditive_expr();\n          if (s6 !== peg$FAILED) {\n            s3 = [s3, s4, s5, s6];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsearithmetic_comparison_operator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e7);\n    if (input.substr(peg$currPos, 2) === peg$c6) {\n      s0 = peg$c6;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      rule$expects(peg$e8);\n      if (input.charCodeAt(peg$currPos) === 62) {\n        s0 = peg$c7;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        rule$expects(peg$e9);\n        if (input.substr(peg$currPos, 2) === peg$c8) {\n          s0 = peg$c8;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          rule$expects(peg$e10);\n          if (input.substr(peg$currPos, 2) === peg$c9) {\n            s0 = peg$c9;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            rule$expects(peg$e11);\n            if (input.charCodeAt(peg$currPos) === 60) {\n              s0 = peg$c10;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              rule$expects(peg$e6);\n              if (input.charCodeAt(peg$currPos) === 61) {\n                s0 = peg$c5;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                rule$expects(peg$e12);\n                if (input.substr(peg$currPos, 2) === peg$c11) {\n                  s0 = peg$c11;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseis_op_right() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_IS();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseadditive_expr();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f19(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebetween_op_right() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_BETWEEN();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseadditive_expr();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseKW_AND();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseadditive_expr();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f20(s1, s3, s7);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselike_op() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseKW_NOT();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseKW_LIKE();\n      if (s4 !== peg$FAILED) {\n        s2 = [s2, s3, s4];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f21(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseKW_LIKE();\n    }\n\n    return s0;\n  }\n\n  function peg$parsein_op() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseKW_NOT();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseKW_IN();\n      if (s4 !== peg$FAILED) {\n        s2 = [s2, s3, s4];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f21(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseKW_IN();\n    }\n\n    return s0;\n  }\n\n  function peg$parsecontains_op() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseKW_NOT();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse__();\n      s4 = peg$parseKW_CONTAINS();\n      if (s4 !== peg$FAILED) {\n        s2 = [s2, s3, s4];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f21(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseKW_CONTAINS();\n    }\n\n    return s0;\n  }\n\n  function peg$parselike_op_right() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parselike_op();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parsecomparison_expr();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f19(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsein_op_right() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsein_op();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseLPAREN();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseexpr_list();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseRPAREN();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f22(s1, s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecontains_op_right() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsecontains_op();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseliteral();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f22(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditive_expr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiplicative_expr();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseadditive_operator();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parsemultiplicative_expr();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseadditive_operator();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parsemultiplicative_expr();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f15(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseadditive_operator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e13);\n    if (input.charCodeAt(peg$currPos) === 43) {\n      s0 = peg$c12;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      rule$expects(peg$e14);\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s0 = peg$c13;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicative_expr() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseprimary();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parsemultiplicative_operator();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseprimary();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parsemultiplicative_operator();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseprimary();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f23(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemultiplicative_operator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e15);\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s0 = peg$c14;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      rule$expects(peg$e4);\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s0 = peg$c3;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        rule$expects(peg$e16);\n        if (input.charCodeAt(peg$currPos) === 37) {\n          s0 = peg$c15;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseprimary() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseliteral();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseaggr_func();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecolumn_ref();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseLPAREN();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse__();\n            s3 = peg$parseor_expr();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              s5 = peg$parseRPAREN();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f24(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn_ref() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseident();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseDOT();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parsecolumn();\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f25(s1, s5);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecolumn();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f26(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolumn();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseCOMMA();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parsecolumn();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parsecolumn();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseident() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseident_name();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f27(s1);\n      if (s2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = undefined;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f28(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseident_name();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f27(s1);\n      if (s2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = undefined;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f28(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      rule$expects(peg$e3);\n      if (input.charCodeAt(peg$currPos) === 96) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        rule$expects(peg$e17);\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            rule$expects(peg$e17);\n            if (peg$r0.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          rule$expects(peg$e3);\n          if (input.charCodeAt(peg$currPos) === 96) {\n            s3 = peg$c2;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f29(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseident_name() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseident_part();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseident_part();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f30(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseident_start() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e18);\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseident_part() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e19);\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseaggr_func() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_SUM_MAX_MIN_AVG();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseLPAREN();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        s5 = peg$parseident_name();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseRPAREN();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f31(s1, s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_SUM_MAX_MIN_AVG() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_SUM();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseKW_MAX();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseKW_MIN();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseKW_AVG();\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsestar_expr() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c14;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f33();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseliteral() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parseliteral_string();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseliteral_numeric();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseliteral_bool();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseliteral_null();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseliteral_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseliteral();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseCOMMA();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseliteral();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseCOMMA();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseliteral();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseliteral_null() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_NULL();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f34();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseliteral_bool() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseKW_TRUE();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f35();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseKW_FALSE();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f36();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseliteral_string() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    rule$expects(peg$e20);\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s2 = peg$c16;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsedouble_char();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsedouble_char();\n      }\n      rule$expects(peg$e20);\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s4 = peg$c16;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s2 = [s2, s3, s4];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      rule$expects(peg$e21);\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s2 = peg$c17;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsesingle_char();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsesingle_char();\n        }\n        rule$expects(peg$e21);\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s4 = peg$c17;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f37(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesingle_char() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e22);\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseescape_char();\n    }\n\n    return s0;\n  }\n\n  function peg$parsedouble_char() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e23);\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseescape_char();\n    }\n\n    return s0;\n  }\n\n  function peg$parseescape_char() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e24);\n    if (input.substr(peg$currPos, 2) === peg$c18) {\n      s1 = peg$c18;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f38();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      rule$expects(peg$e25);\n      if (input.substr(peg$currPos, 2) === peg$c19) {\n        s1 = peg$c19;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f39();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        rule$expects(peg$e26);\n        if (input.substr(peg$currPos, 2) === peg$c20) {\n          s1 = peg$c20;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f40();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          rule$expects(peg$e27);\n          if (input.substr(peg$currPos, 2) === peg$c21) {\n            s1 = peg$c21;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f41();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            rule$expects(peg$e28);\n            if (input.substr(peg$currPos, 2) === peg$c22) {\n              s1 = peg$c22;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f42();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              rule$expects(peg$e29);\n              if (input.substr(peg$currPos, 2) === peg$c23) {\n                s1 = peg$c23;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f43();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                rule$expects(peg$e30);\n                if (input.substr(peg$currPos, 2) === peg$c24) {\n                  s1 = peg$c24;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f44();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  rule$expects(peg$e31);\n                  if (input.substr(peg$currPos, 2) === peg$c25) {\n                    s1 = peg$c25;\n                    peg$currPos += 2;\n                  } else {\n                    s1 = peg$FAILED;\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$f45();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    rule$expects(peg$e32);\n                    if (input.substr(peg$currPos, 2) === peg$c26) {\n                      s1 = peg$c26;\n                      peg$currPos += 2;\n                    } else {\n                      s1 = peg$FAILED;\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$f46();\n                    }\n                    s0 = s1;\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      rule$expects(peg$e33);\n                      if (input.substr(peg$currPos, 2) === peg$c27) {\n                        s1 = peg$c27;\n                        peg$currPos += 2;\n                      } else {\n                        s1 = peg$FAILED;\n                      }\n                      if (s1 !== peg$FAILED) {\n                        s2 = peg$parsehexDigit();\n                        if (s2 !== peg$FAILED) {\n                          s3 = peg$parsehexDigit();\n                          if (s3 !== peg$FAILED) {\n                            s4 = peg$parsehexDigit();\n                            if (s4 !== peg$FAILED) {\n                              s5 = peg$parsehexDigit();\n                              if (s5 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f47(s2, s3, s4, s5);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseline_terminator() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseliteral_numeric() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f48(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseliteral_int() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e34);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseint();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f49(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseint();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefrac();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexp();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          peg$savedPos = s0;\n          s0 = peg$f50(s1, s2, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseint();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsefrac();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          peg$savedPos = s0;\n          s0 = peg$f51(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseint();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseexp();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            peg$savedPos = s0;\n            s0 = peg$f52(s1, s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseint();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse__();\n            peg$savedPos = s0;\n            s0 = peg$f53(s1);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseint() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigit19();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedigits();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f54(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsedigit();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        rule$expects(peg$e14);\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c13;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          rule$expects(peg$e13);\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s1 = peg$c12;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsedigit19();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsedigits();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f55(s1, s2, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          rule$expects(peg$e14);\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s1 = peg$c13;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            rule$expects(peg$e13);\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s1 = peg$c12;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsedigit();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f56(s1, s2);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefrac() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e35);\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c28;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedigits();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f57(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseexp() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsee();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedigits();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f58(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigits() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedigit();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsedigit();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f59(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e36);\n    peg$silentFails++;\n    if (peg$r6.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parsedigit19() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e36);\n    peg$silentFails++;\n    if (peg$r7.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parsehexDigit() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e37);\n    peg$silentFails++;\n    if (peg$r8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parsee() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e38);\n    if (peg$r9.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      rule$expects(peg$e39);\n      if (peg$r10.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f60(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_NULL() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e40);\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c29) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_TRUE() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e41);\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c30) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_FALSE() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e42);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c31) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_SHOW() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c32) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_SELECT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e43);\n    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c33) {\n      s1 = input.substr(peg$currPos, 6);\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_FROM() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e44);\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c34) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_AS() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e45);\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c35) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_TABLE() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c36) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_UNION() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e46);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c37) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_IF() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c38) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_EXISTS() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c39) {\n      s1 = input.substr(peg$currPos, 6);\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_WHERE() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e47);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c40) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_GROUP() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e48);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c41) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_BY() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e49);\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c42) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_ORDER() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e50);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c43) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_LIMIT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e51);\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c44) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_ASC() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e52);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c45) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f61();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_DESC() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e53);\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c46) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f62();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_ALL() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c47) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f63();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_DISTINCT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e54);\n    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c48) {\n      s1 = input.substr(peg$currPos, 8);\n      peg$currPos += 8;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f64();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_BETWEEN() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e55);\n    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c49) {\n      s1 = input.substr(peg$currPos, 7);\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f65();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_IN() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e56);\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c50) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f66();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_IS() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e57);\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c51) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f67();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_LIKE() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e58);\n    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c52) {\n      s1 = input.substr(peg$currPos, 4);\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f68();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_CONTAINS() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e59);\n    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c53) {\n      s1 = input.substr(peg$currPos, 8);\n      peg$currPos += 8;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f69();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_NOT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e60);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c54) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f70();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_AND() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e61);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c55) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f71();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_OR() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e62);\n    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c56) {\n      s1 = input.substr(peg$currPos, 2);\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f72();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_COUNT() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c57) {\n      s1 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f73();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_MAX() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e63);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c58) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f74();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_MIN() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e64);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c59) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f75();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_SUM() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e65);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c60) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f76();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseKW_AVG() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e66);\n    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c61) {\n      s1 = input.substr(peg$currPos, 3);\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$begin();\n      s3 = peg$parseident_start();\n      peg$end(true);\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f77();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDOT() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e35);\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s0 = peg$c28;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCOMMA() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e67);\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c62;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSTAR() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s0 = peg$c14;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLPAREN() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e0);\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s0 = peg$c0;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseRPAREN() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e1);\n    if (input.charCodeAt(peg$currPos) === 41) {\n      s0 = peg$c1;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = [];\n    s1 = peg$parsewhitespace();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parsewhitespace();\n    }\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e68);\n    peg$silentFails++;\n    if (peg$r11.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n\n    function createUnaryExpr(op, e) {\n      return {\n        type     : 'unary_expr',\n        operator : op,\n        expr     : e\n      }\n    }\n\n    function createBinaryExpr(op, left, right) {\n      return {\n        type      : 'binary_expr',\n        operator  : op,\n        left      : left,\n        right     : right\n      }\n    }\n\n    function createList(head, tail) {\n      var result = [head];\n      for (var i = 0; i < tail.length; i++) {\n        result.push(tail[i][3]);\n      }\n      return result;\n    }\n\n    function createExprList(head, tail, room) {\n      var epList = createList(head, tail);\n      var exprList  = [];\n      var ep;\n      for (var i = 0; i < epList.length; i++) {\n        ep = epList[i];\n        exprList.push(ep);\n      }\n      return exprList;\n    }\n\n    function createBinaryExprChain(head, tail) {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = createBinaryExpr(tail[i][1], result, tail[i][3]);\n      }\n      return result;\n    }\n\n    var reservedMap = {\n      'SHOW'    : true,\n      'DROP'    : true,\n      'SELECT'  : true,\n      'UPDATE'  : true,\n      'CREATE'  : true,\n      'DELETE'  : true,\n      'INSERT'  : true,\n      'REPLACE' : true,\n      'EXPLAIN' : true,\n      'ALL'     : true,\n      'DISTINCT': true,\n      'AS'      : true,\n      'TABLE'   : true,\n      'INTO'    : true,\n      'FROM'    : true,\n      'SET'     : true,\n      'LEFT'    : true,\n      'ON'      : true,\n      'INNER'   : true,\n      'JOIN'    : true,\n      'UNION'   : true,\n      'VALUES'  : true,\n      'EXISTS'  : true,\n      'WHERE'   : true,\n      'GROUP'   : true,\n      'BY'      : true,\n      'HAVING'  : true,\n      'ORDER'   : true,\n      'ASC'     : true,\n      'DESC'    : true,\n      'LIMIT'   : true,\n      'BETWEEN' : true,\n      'IN'      : true,\n      'IS'      : true,\n      'LIKE'    : true,\n      'CONTAINS': true,\n      'NOT'     : true,\n      'AND'     : true,\n      'OR'      : true,\n\n      //literal\n      'TRUE'    : true,\n      'FALSE'   : true,\n      'NULL'    : true\n    }\n\n\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n\n    throw peg$buildError();\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","import { SQL_Value, SQL_AggrFunction } from './sql-parser';\n\nexport type DocumentData = { [field: string]: any };\n\nexport type ValueOf<T> = T[keyof T];\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\nexport function assert(condition: boolean, message: string) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexport function contains(obj: object, prop: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function safeGet(obj: any, prop: string): any {\n  if (contains(obj, prop)) return obj[prop];\n}\n\nexport function deepGet(obj: any, path: string): any {\n  let value = obj;\n  const props = path.split('.');\n\n  props.some(prop => {\n    value = safeGet(value, prop);\n\n    // By using \"some\" instead of \"forEach\", we can return\n    // true whenever we want to break out of the loop.\n    return typeof value === void 0;\n  });\n\n  return value;\n}\n\nexport function astValueToNative(\n  astValue: SQL_Value\n): boolean | string | number | null {\n  let value: boolean | string | number | null;\n\n  switch (astValue.type) {\n    case 'bool':\n    case 'null':\n    case 'string':\n      value = astValue.value;\n      break;\n    case 'number':\n      value = Number(astValue.value);\n      break;\n    default:\n      throw new Error('Unsupported value type in WHERE clause.');\n  }\n\n  return value;\n}\n/**\n * Adapted from: https://github.com/firebase/firebase-ios-sdk/blob/14dd9dc2704038c3bf702426439683cee4dc941a/Firestore/core/src/firebase/firestore/util/string_util.cc#L23-L40\n */\nexport function prefixSuccessor(prefix: string): string {\n  // We can increment the last character in the string and be done\n  // unless that character is 255 (0xff), in which case we have to erase the\n  // last character and increment the previous character, unless that\n  // is 255, etc. If the string is empty or consists entirely of\n  // 255's, we just return the empty string.\n  let limit = prefix;\n  while (limit.length > 0) {\n    const index = limit.length - 1;\n    if (limit[index] === '\\xff') {\n      limit = limit.slice(0, -1);\n    } else {\n      limit =\n        limit.substr(0, index) +\n        String.fromCharCode(limit.charCodeAt(index) + 1);\n      break;\n    }\n  }\n  return limit;\n}\n\nexport function nameOrAlias(\n  name: string,\n  alias: string | null,\n  aggrFn?: SQL_AggrFunction\n): string {\n  if (alias !== null && alias.length > 0) {\n    return alias;\n  }\n\n  if (!aggrFn) {\n    return name;\n  }\n\n  return `${aggrFn.name}(${name})`;\n}\n","import { SQL_GroupBy } from '../sql-parser';\nimport { assert, safeGet, contains, DocumentData, ValueOf } from '../utils';\n\nexport function applyGroupByLocally(\n  documents: DocumentData[],\n  astGroupBy: SQL_GroupBy[]\n): GroupedDocuments {\n  assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');\n\n  let group: ValueOf<GroupedDocuments> = new DocumentsGroup();\n  group.documents = documents;\n\n  astGroupBy.forEach(groupBy => {\n    assert(\n      groupBy.type === 'column_ref',\n      'GROUP BY only supports grouping by field names.'\n    );\n    group = applySingleGroupBy(group, groupBy);\n  });\n\n  return (group as any) as GroupedDocuments;\n}\n\nfunction applySingleGroupBy(\n  documents: ValueOf<GroupedDocuments>,\n  groupBy: SQL_GroupBy\n): GroupedDocuments {\n  const groupedDocs: GroupedDocuments = {};\n\n  if (documents instanceof DocumentsGroup) {\n    // We just have a list of documents\n    const numDocs = documents.documents.length;\n\n    for (let i = 0; i < numDocs; i++) {\n      const doc = documents.documents[i];\n\n      // Since we're going to use the value as an object key, always\n      // coherce it to a string in case it's some other type.\n      const groupValue = String(safeGet(doc, groupBy.column));\n\n      if (!contains(groupedDocs, groupValue)) {\n        groupedDocs[groupValue] = new DocumentsGroup();\n      }\n\n      (groupedDocs[groupValue] as DocumentsGroup).documents.push(doc);\n    }\n\n    return groupedDocs;\n  } else {\n    // We have documents that have already been grouped with another field\n    const currentGroups = Object.keys(documents);\n    currentGroups.forEach(group => {\n      groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);\n    });\n    return groupedDocs;\n  }\n}\n\nexport class DocumentsGroup {\n  documents: DocumentData[] = [];\n  aggr: GroupAggregateValues = {\n    sum: {},\n    avg: {},\n    min: {},\n    max: {},\n    total: {}\n  };\n\n  constructor(public key?: string) {}\n}\n\nexport interface GroupedDocuments {\n  [key: string]: GroupedDocuments | DocumentsGroup;\n}\n\nexport interface GroupAggregateValues {\n  sum: { [k: string]: number };\n  avg: { [k: string]: number };\n  min: { [k: string]: number | string };\n  max: { [k: string]: number | string };\n  total: { [k: string]: number };\n}\n","import { SQL_Value, SQL_ValueString, SQL_ValueBool } from '../sql-parser';\nimport { assert, prefixSuccessor, astValueToNative } from '../utils';\n\nexport function applyWhere(\n  queries: firebase.firestore.Query[],\n  astWhere: { [k: string]: any }\n): firebase.firestore.Query[] {\n  if (astWhere.type === 'binary_expr') {\n    if (astWhere.operator === 'AND') {\n      queries = applyWhere(queries, astWhere.left);\n      queries = applyWhere(queries, astWhere.right);\n    } else if (astWhere.operator === 'OR') {\n      queries = [\n        ...applyWhere(queries, astWhere.left),\n        ...applyWhere(queries, astWhere.right)\n      ];\n    } else if (astWhere.operator === 'IN') {\n      assert(\n        astWhere.left.type === 'column_ref',\n        'Unsupported WHERE type on left side.'\n      );\n      assert(\n        astWhere.right.type === 'expr_list',\n        'Unsupported WHERE type on right side.'\n      );\n\n      const newQueries: firebase.firestore.Query[] = [];\n      astWhere.right.value.forEach((valueObj: SQL_Value) => {\n        newQueries.push(\n          ...applyCondition(queries, astWhere.left.column, '=', valueObj)\n        );\n      });\n      queries = newQueries;\n    } else if (astWhere.operator === 'LIKE') {\n      assert(\n        astWhere.left.type === 'column_ref',\n        'Unsupported WHERE type on left side.'\n      );\n      assert(\n        astWhere.right.type === 'string',\n        'Only strings are supported with LIKE in WHERE clause.'\n      );\n\n      const whereLike = parseWhereLike(astWhere.right.value);\n\n      if (whereLike.equals !== void 0) {\n        queries = applyCondition(\n          queries,\n          astWhere.left.column,\n          '=',\n          whereLike.equals\n        );\n      } else if (whereLike.beginsWith !== void 0) {\n        const successorStr = prefixSuccessor(whereLike.beginsWith.value);\n        queries = applyCondition(\n          queries,\n          astWhere.left.column,\n          '>=',\n          whereLike.beginsWith\n        );\n        queries = applyCondition(\n          queries,\n          astWhere.left.column,\n          '<',\n          stringASTWhereValue(successorStr)\n        );\n      } else {\n        throw new Error(\n          'Only terms in the form of \"value%\" (string begins with value) and \"value\" (string equals value) are supported with LIKE in WHERE clause.'\n        );\n      }\n    } else if (astWhere.operator === 'BETWEEN') {\n      assert(\n        astWhere.left.type === 'column_ref',\n        'Unsupported WHERE type on left side.'\n      );\n      assert(\n        astWhere.right.type === 'expr_list' &&\n          astWhere.right.value.length === 2,\n        'BETWEEN needs 2 values in WHERE clause.'\n      );\n\n      queries = applyCondition(\n        queries,\n        astWhere.left.column,\n        '>=',\n        astWhere.right.value[0]\n      );\n      queries = applyCondition(\n        queries,\n        astWhere.left.column,\n        '<=',\n        astWhere.right.value[1]\n      );\n    } else if (astWhere.operator === 'CONTAINS') {\n      assert(\n        astWhere.left.type === 'column_ref',\n        'Unsupported WHERE type on left side.'\n      );\n      assert(\n        ['string', 'number', 'bool', 'null'].includes(astWhere.right.type),\n        'Only strings, numbers, booleans, and null are supported with CONTAINS in WHERE clause.'\n      );\n\n      queries = applyCondition(\n        queries,\n        astWhere.left.column,\n        astWhere.operator,\n        astWhere.right\n      );\n    } else {\n      assert(\n        astWhere.left.type === 'column_ref',\n        'Unsupported WHERE type on left side.'\n      );\n\n      queries = applyCondition(\n        queries,\n        astWhere.left.column,\n        astWhere.operator,\n        astWhere.right\n      );\n    }\n  } else if (astWhere.type === 'column_ref') {\n    // The query is like \"... WHERE column_name\", so lets return\n    // the documents where \"column_name\" is true. Ideally we would\n    // include any document where \"column_name\" is truthy, but there's\n    // no way to do that with Firestore.\n    queries = queries.map(query => query.where(astWhere.column, '==', true));\n  } else {\n    throw new Error('Unsupported WHERE clause');\n  }\n\n  return queries;\n}\n\nfunction applyCondition(\n  queries: firebase.firestore.Query[],\n  field: string,\n  astOperator: string,\n  astValue: SQL_Value\n): firebase.firestore.Query[] {\n  /*\n   TODO: Several things:\n\n    - If we're applying a range condition to a query (<, <=, >, >=)\n      we need to make sure that any other range condition on that same\n      query is only applied to the same field. Firestore doesn't\n      allow range conditions on several fields in the same query.\n\n    - If we apply a range condition, the first .orderBy() needs to\n      be on that same field. We should wait and only apply it if\n      the user has requested an ORDER BY. Otherwise, they might be\n      expecting the results ordered by document id.\n\n    - Can't combine \"LIKE 'value%'\" and inequality filters (>, <=, ...)\n      with AND:\n        SELECT * FROM shops WHERE rating > 2 AND name LIKE 'T%'\n      In theory it's only a problem when they're on the same field,\n      but since applying those on different fields doesn't make any\n      sense it's easier if we just disallow it in any case.\n      It's OK if it's with an OR (not the same query):\n        SELECT * FROM shops WHERE rating > 2 OR name LIKE 'T%'\n  */\n\n  if (astOperator === '!=' || astOperator === '<>') {\n    if (astValue.type === 'bool') {\n      // If the value is a boolean, then just perform a == operation\n      // with the negation of the value.\n      const negValue: SQL_ValueBool = { type: 'bool', value: !astValue.value };\n      return applyCondition(queries, field, '=', negValue);\n    } else {\n      // The != operator is not supported in Firestore so we\n      // split this query in two, one with the < operator and\n      // another one with the > operator.\n      return [\n        ...applyCondition(queries, field, '<', astValue),\n        ...applyCondition(queries, field, '>', astValue)\n      ];\n    }\n  } else {\n    const value = astValueToNative(astValue);\n    const operator = whereFilterOp(astOperator);\n    return queries.map(query => query.where(field, operator, value));\n  }\n}\n\nfunction whereFilterOp(op: string): firebase.firestore.WhereFilterOp {\n  let newOp: firebase.firestore.WhereFilterOp;\n\n  switch (op) {\n    case '=':\n    case 'IS':\n      newOp = '==';\n      break;\n    case '<':\n    case '<=':\n    case '>':\n    case '>=':\n      newOp = op;\n      break;\n    case 'CONTAINS':\n      newOp = 'array-contains';\n      break;\n    case 'NOT':\n    case 'NOT CONTAINS':\n      throw new Error('\"NOT\" WHERE operator unsupported');\n      break;\n    default:\n      throw new Error('Unknown WHERE operator');\n  }\n\n  return newOp;\n}\n\ninterface WhereLikeResult {\n  beginsWith?: SQL_ValueString;\n  endsWith?: SQL_ValueString;\n  contains?: SQL_ValueString;\n  equals?: SQL_ValueString;\n}\n\nfunction stringASTWhereValue(str: string): SQL_ValueString {\n  return {\n    type: 'string',\n    value: str\n  };\n}\n\nfunction parseWhereLike(str: string): WhereLikeResult {\n  const result: WhereLikeResult = {};\n  const strLength = str.length;\n\n  if (str[0] === '%') {\n    if (str[strLength - 1] === '%') {\n      result.contains = stringASTWhereValue(str.substr(1, strLength - 2));\n    } else {\n      result.endsWith = stringASTWhereValue(str.substring(1));\n    }\n  } else if (str[strLength - 1] === '%') {\n    result.beginsWith = stringASTWhereValue(str.substr(0, strLength - 1));\n  } else {\n    result.equals = stringASTWhereValue(str);\n  }\n\n  return result;\n}\n","import { QueryOptions } from '../shared';\nimport {\n  SQL_SelectColumn,\n  SQL_ColumnRef,\n  SQL_AggrFunction,\n  SQL_Select\n} from '../sql-parser';\nimport {\n  assert,\n  contains,\n  deepGet,\n  DocumentData,\n  safeGet,\n  nameOrAlias,\n  DOCUMENT_KEY_NAME\n} from '../utils';\nimport {\n  applyGroupByLocally,\n  GroupedDocuments,\n  GroupAggregateValues,\n  DocumentsGroup\n} from './groupby';\nimport { applyOrderBy, applyOrderByLocally } from './orderby';\nimport { applyLimit, applyLimitLocally } from './limit';\nimport { applyWhere } from './where';\n\nconst VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];\n\nexport async function select_(\n  ref: firebase.firestore.DocumentReference,\n  ast: SQL_Select,\n  options: QueryOptions\n): Promise<DocumentData[]> {\n  const selectOp = new SelectOperation(ref, ast, options);\n  const queries = selectOp.generateQueries_();\n  const documents = await selectOp.executeQueries_(queries);\n  return selectOp.processDocuments_(queries, documents);\n}\n\nexport class SelectOperation {\n  _includeId?: boolean | string;\n\n  constructor(\n    private _ref: firebase.firestore.DocumentReference,\n    private _ast: SQL_Select,\n    options: QueryOptions\n  ) {\n    // We need to determine if we have to include\n    // the document's ID (__name__) in the results.\n    this._includeId = options.includeId || false;\n    if (!this._includeId && Array.isArray(_ast.columns)) {\n      for (let i = 0; i < _ast.columns.length; i++) {\n        if (_ast.columns[i].expr.type === 'column_ref') {\n          if (\n            (_ast.columns[i].expr as SQL_ColumnRef).column === DOCUMENT_KEY_NAME\n          ) {\n            this._includeId = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (this._includeId === void 0) {\n      this._includeId = false;\n    }\n  }\n\n  generateQueries_(ast?: SQL_Select): firebase.firestore.Query[] {\n    ast = ast || this._ast;\n\n    assert(\n      ast.from.parts.length % 2 === 1,\n      '\"FROM\" needs a path to a collection (odd number of parts).'\n    );\n\n    const path = ast.from.parts.join('/');\n    let queries: firebase.firestore.Query[] = [];\n\n    if (ast.from.group) {\n      assert(\n        this._ref.path === '',\n        'Collection group queries are only allowed from the root of the database.'\n      );\n\n      const firestore = contains(this._ref, 'firestore')\n        ? this._ref.firestore\n        : ((this._ref as any) as firebase.firestore.Firestore);\n\n      assert(\n        typeof (firestore as any).collectionGroup === 'function',\n        `Your version of the Firebase SDK doesn't support collection group queries.`\n      );\n      queries.push((firestore as any).collectionGroup(path));\n    } else {\n      queries.push(this._ref.collection(path));\n    }\n\n    /*\n     * We'd need this if we end up implementing JOINs, but for now\n     * it's unnecessary since we're only querying a single collection\n    \n      // Keep track of aliased \"tables\" (collections)\n      const aliasedCollections: { [k: string]: string } = {};\n      if (ast.from[0].as.length > 0) {\n        aliasedCollections[ast.from[0].as] = colName;\n      } else {\n        aliasedCollections[colName] = colName;\n      }\n   */\n\n    if (ast.where) {\n      queries = applyWhere(queries, ast.where);\n    }\n\n    if (ast.orderby) {\n      queries = applyOrderBy(queries, ast.orderby);\n\n      /*\n       FIXME: the following query throws an error:\n          SELECT city, name\n          FROM restaurants\n          WHERE city IN ('Nashvile', 'Denver')\n          ORDER BY city, name\n  \n       It happens because \"WHERE ... IN ...\" splits into 2 separate\n       queries with a \"==\" filter, and an order by clause cannot\n       contain a field with an equality filter:\n          ...where(\"city\",\"==\",\"Denver\").orderBy(\"city\")\n      */\n    }\n\n    // if (ast.groupby) {\n    //   throw new Error('GROUP BY not supported yet');\n    // }\n\n    if (ast.limit) {\n      // First we apply the limit to each query we may have\n      // and later we'll apply it again locally to the\n      // merged set of documents, in case we end up with too many.\n      queries = applyLimit(queries, ast.limit);\n    }\n\n    if (ast._next) {\n      assert(\n        ast._next.type === 'select',\n        ' UNION statements are only supported between SELECTs.'\n      );\n      // This is the UNION of 2 SELECTs, so lets process the second\n      // one and merge their queries\n      queries = queries.concat(this.generateQueries_(ast._next));\n\n      // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n      // SELECT only, instead of to the whole UNION. Find a workaround.\n    }\n\n    return queries;\n  }\n\n  async executeQueries_(\n    queries: firebase.firestore.Query[]\n  ): Promise<DocumentData[]> {\n    let documents: DocumentData[] = [];\n    const seenDocuments: { [id: string]: true } = {};\n\n    try {\n      await Promise.all(\n        queries.map(async query => {\n          const snapshot = await query.get();\n          const numDocs = snapshot.docs.length;\n\n          for (let i = 0; i < numDocs; i++) {\n            const docSnap = snapshot.docs[i];\n            const docPath = docSnap.ref.path;\n\n            if (!contains(seenDocuments, docPath)) {\n              const docData = docSnap.data();\n\n              if (this._includeId) {\n                docData[\n                  typeof this._includeId === 'string'\n                    ? this._includeId\n                    : DOCUMENT_KEY_NAME\n                ] = docSnap.id;\n              }\n\n              documents.push(docData);\n              seenDocuments[docPath] = true;\n            }\n          }\n        })\n      );\n    } catch (err) {\n      // TODO: handle error?\n      throw err;\n    }\n\n    return documents;\n  }\n\n  processDocuments_(\n    queries: firebase.firestore.Query[],\n    documents: DocumentData[]\n  ): DocumentData[] {\n    if (documents.length === 0) {\n      return [];\n    } else {\n      if (this._ast.groupby) {\n        const groupedDocs = applyGroupByLocally(documents, this._ast.groupby);\n        return this._processGroupedDocs(queries, groupedDocs);\n      } else {\n        return this._processUngroupedDocs(queries, documents);\n      }\n    }\n  }\n\n  private _processUngroupedDocs(\n    queries: firebase.firestore.Query[],\n    documents: DocumentData[]\n  ): DocumentData[] {\n    if (this._ast.orderby && queries.length > 1) {\n      // We merged more than one query into a single set of documents\n      // so we need to order the documents again, this time client-side.\n      documents = applyOrderByLocally(documents, this._ast.orderby);\n    }\n\n    if (this._ast.limit && queries.length > 1) {\n      // We merged more than one query into a single set of documents\n      // so we need to apply the limit again, this time client-side.\n      documents = applyLimitLocally(documents, this._ast.limit);\n    }\n\n    if (typeof this._ast.columns === 'string' && this._ast.columns === '*') {\n      // Return all fields from the documents\n    } else if (Array.isArray(this._ast.columns)) {\n      const aggrColumns = getAggrColumns(this._ast.columns);\n\n      if (aggrColumns.length > 0) {\n        const docsGroup = new DocumentsGroup();\n        docsGroup.documents = documents;\n        aggregateDocuments(docsGroup, aggrColumns);\n\n        /// Since there is no GROUP BY and we already computed all\n        // necessary aggregated values, at this point we only care\n        // about the first document in the list. Anything else is\n        // irrelevant.\n        const resultEntry = this._buildResultEntry(\n          docsGroup.documents[0],\n          docsGroup.aggr\n        );\n\n        documents = [resultEntry];\n      } else {\n        documents = documents.map(doc => this._buildResultEntry(doc));\n      }\n    } else {\n      // We should never reach here\n      throw new Error('Internal error (ast.columns).');\n    }\n\n    return documents;\n  }\n\n  private _processGroupedDocs(\n    queries: firebase.firestore.Query[],\n    groupedDocs: GroupedDocuments\n  ): DocumentData[] {\n    assert(this._ast.columns !== '*', 'Cannot \"SELECT *\" when using GROUP BY.');\n\n    const aggrColumns = getAggrColumns(this._ast.columns);\n    const groups = flattenGroupedDocs(groupedDocs);\n\n    if (aggrColumns.length === 0) {\n      // We're applying a GROUP BY but none of the fields requested\n      // in the SELECT are an aggregate function. In this case we\n      // just return an entry for the first document.\n      const firstGroupKey = Object.keys(groups)[0];\n      const firstGroup = groups[firstGroupKey];\n      const firstDoc = firstGroup.documents[0];\n      return [this._buildResultEntry(firstDoc)];\n    } else {\n      const results: DocumentData[] = [];\n\n      // TODO: ORDER BY\n      assert(\n        !this._ast.orderby,\n        'ORDER BY is not yet supported when using GROUP BY.'\n      );\n\n      // TODO: LIMIT\n      assert(\n        !this._ast.limit,\n        'LIMIT is not yet supported when using GROUP BY.'\n      );\n\n      Object.keys(groups).forEach(groupKey => {\n        const docsGroup = groups[groupKey];\n        aggregateDocuments(docsGroup, aggrColumns);\n\n        const resultEntry = this._buildResultEntry(\n          docsGroup.documents[0],\n          docsGroup.aggr\n        );\n\n        results.push(resultEntry);\n      });\n\n      return results;\n    }\n  }\n\n  private _buildResultEntry(\n    document: DocumentData,\n    aggregate?: GroupAggregateValues,\n    asFieldArray?: false\n  ): DocumentData;\n  private _buildResultEntry(\n    document: DocumentData,\n    aggregate?: GroupAggregateValues,\n    asFieldArray?: true\n  ): AliasedField[];\n  private _buildResultEntry(\n    document: DocumentData,\n    aggregate?: GroupAggregateValues,\n    asFieldArray = false\n  ): DocumentData | AliasedField[] {\n    let idIncluded = false;\n    const columns = this._ast.columns as SQL_SelectColumn[];\n\n    const resultFields: AliasedField[] = columns.reduce(\n      (entries: AliasedField[], column) => {\n        let fieldName: string;\n        let fieldAlias: string;\n\n        switch (column.expr.type) {\n          case 'column_ref':\n            fieldName = column.expr.column;\n            fieldAlias = nameOrAlias(fieldName, column.as);\n            entries.push(\n              new AliasedField(\n                fieldName,\n                fieldAlias,\n                deepGet(document, fieldName)\n              )\n            );\n            if (fieldName === DOCUMENT_KEY_NAME) {\n              idIncluded = true;\n            }\n            break;\n\n          case 'aggr_func':\n            vaidateAggrFunction(column.expr);\n            fieldName = column.expr.field;\n            fieldAlias = nameOrAlias(fieldName, column.as, column.expr);\n            entries.push(\n              new AliasedField(\n                fieldName,\n                fieldAlias,\n                (aggregate! as any)[column.expr.name.toLowerCase()][fieldName]\n              )\n            );\n            break;\n\n          default:\n            throw new Error('Unsupported type in SELECT.');\n        }\n\n        return entries;\n      },\n      []\n    );\n\n    if (this._includeId && !idIncluded) {\n      resultFields.push(\n        new AliasedField(\n          DOCUMENT_KEY_NAME,\n          typeof this._includeId === 'string'\n            ? this._includeId\n            : DOCUMENT_KEY_NAME,\n          safeGet(document, DOCUMENT_KEY_NAME)\n        )\n      );\n    }\n\n    if (asFieldArray) {\n      return resultFields;\n    } else {\n      return resultFields.reduce((doc: DocumentData, field: AliasedField) => {\n        doc[field.alias] = field.value;\n        return doc;\n      }, {});\n    }\n  }\n}\n\n/*************************************************/\n\nfunction aggregateDocuments(\n  docsGroup: DocumentsGroup,\n  functions: SQL_AggrFunction[]\n): DocumentsGroup {\n  const numDocs = docsGroup.documents.length;\n\n  for (let i = 0; i < numDocs; i++) {\n    const doc = docsGroup.documents[i];\n\n    // If the same field is used in more than one aggregate function\n    // we don't want to sum its value more than once.\n    const skipSum: { [field: string]: true } = {};\n\n    functions.forEach(fn => {\n      let value = safeGet(doc, fn.field);\n      const isNumber = !Number.isNaN(value);\n\n      switch (fn.name) {\n        case 'AVG':\n          // Lets put a value so that later we know we have to compute this avg\n          docsGroup.aggr.avg[fn.field] = 0;\n        // tslint:disable-next-line:no-switch-case-fall-through\n        case 'SUM':\n          if (safeGet(skipSum, fn.field) !== true) {\n            skipSum[fn.field] = true;\n            if (!contains(docsGroup.aggr.total, fn.field)) {\n              docsGroup.aggr.total[fn.field] = 0;\n              docsGroup.aggr.sum[fn.field] = 0;\n            }\n            value = Number(value);\n            assert(\n              !Number.isNaN(value),\n              `Can't compute aggregate function ${fn.name}(${\n                fn.field\n              }) because some values are not numbers.`\n            );\n            docsGroup.aggr.total[fn.field] += 1;\n            docsGroup.aggr.sum[fn.field] += value;\n            // FIXME: if the numbers are big we could easily go out of bounds in this sum\n          }\n          break;\n        case 'MIN':\n          assert(\n            isNumber || typeof value === 'string',\n            `Aggregate function MIN(${\n              fn.field\n            }) can only be performed on numbers or strings`\n          );\n          if (!contains(docsGroup.aggr.min, fn.field)) {\n            docsGroup.aggr.min[fn.field] = value;\n          } else {\n            if (!Number.isNaN(docsGroup.aggr.min[fn.field] as any)) {\n              // The current minimum is a number\n              assert(\n                isNumber,\n                `Can't compute aggregate function MIN(${\n                  fn.field\n                }) because some values are not numbers.`\n              );\n              value = Number(value);\n            }\n            if (value < docsGroup.aggr.min[fn.field]) {\n              docsGroup.aggr.min[fn.field] = value;\n            }\n          }\n          break;\n        case 'MAX':\n          assert(\n            isNumber || typeof value === 'string',\n            `Aggregate function MAX(${\n              fn.field\n            }) can only be performed on numbers or strings`\n          );\n          if (!contains(docsGroup.aggr.max, fn.field)) {\n            docsGroup.aggr.max[fn.field] = value;\n          } else {\n            if (!Number.isNaN(docsGroup.aggr.max[fn.field] as any)) {\n              // The current maximum is a number\n              assert(\n                isNumber,\n                `Can't compute aggregate function MAX(${\n                  fn.field\n                }) because some values are not numbers.`\n              );\n              value = Number(value);\n            }\n            if (value > docsGroup.aggr.max[fn.field]) {\n              docsGroup.aggr.max[fn.field] = value;\n            }\n          }\n          break;\n      }\n    });\n  }\n\n  // Compute any necessary averages\n  Object.keys(docsGroup.aggr.avg).forEach(group => {\n    docsGroup.aggr.avg[group] =\n      docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];\n  });\n\n  return docsGroup;\n}\n\nfunction getAggrColumns(columns: SQL_SelectColumn[] | '*'): SQL_AggrFunction[] {\n  const aggrColumns: SQL_AggrFunction[] = [];\n\n  if (columns !== '*') {\n    columns.forEach(astColumn => {\n      if (astColumn.expr.type === 'aggr_func') {\n        vaidateAggrFunction(astColumn.expr);\n        aggrColumns.push(astColumn.expr);\n      } else {\n        assert(\n          astColumn.expr.type === 'column_ref',\n          'Only field names and aggregate functions are supported in SELECT statements.'\n        );\n      }\n    });\n  }\n\n  return aggrColumns;\n}\n\nfunction vaidateAggrFunction(aggrFn: SQL_AggrFunction) {\n  // TODO: support COUNT, then remove this assert\n  assert(\n    aggrFn.name !== 'COUNT',\n    'Aggregate function COUNT is not yet supported.'\n  );\n\n  assert(\n    VALID_AGGR_FUNCTIONS.includes(aggrFn.name),\n    `Unknown aggregate function '${aggrFn.name}'.`\n  );\n\n  assert(\n    // tslint:disable-next-line: strict-type-predicates\n    typeof aggrFn.field === 'string',\n    `Unsupported type in aggregate function '${aggrFn.name}'.`\n  );\n}\n\nfunction flattenGroupedDocs(\n  groupedDocs: GroupedDocuments\n): { [k: string]: DocumentsGroup } {\n  let result: { [k: string]: any } = {};\n\n  for (let prop in groupedDocs) {\n    if (!contains(groupedDocs, prop)) {\n      continue;\n    }\n\n    if (!(groupedDocs[prop] instanceof DocumentsGroup)) {\n      let flatInner = flattenGroupedDocs(groupedDocs[prop] as GroupedDocuments);\n\n      for (let innerProp in flatInner) {\n        if (!contains(flatInner, innerProp)) {\n          continue;\n        }\n        result[prop + '$$' + innerProp] = flatInner[innerProp];\n      }\n    } else {\n      result[prop] = groupedDocs[prop];\n    }\n  }\n  return result;\n}\n\n/**\n * Represents a field (prop) in a document.\n * It stores the original field name, the assigned alias, and the value.\n *\n * This is necessary in order to properly apply ORDER BY once\n * a result set has been built.\n */\nclass AliasedField {\n  constructor(public name: string, public alias: string, public value: any) {}\n}\n","import { assert } from '../utils';\n\nexport function applyOrderBy(\n  queries: firebase.firestore.Query[],\n  astOrderBy: any[]\n): firebase.firestore.Query[] {\n  astOrderBy.forEach(orderBy => {\n    assert(\n      orderBy.expr.type === 'column_ref',\n      'ORDER BY only supports ordering by field names.'\n    );\n\n    queries = queries.map(query =>\n      query.orderBy(orderBy.expr.column, orderBy.type.toLowerCase())\n    );\n  });\n\n  return queries;\n}\n\nexport function applyOrderByLocally(\n  docs: firebase.firestore.DocumentData[],\n  astOrderBy: any[]\n): firebase.firestore.DocumentData[] {\n  return docs.sort((doc1, doc2) => {\n    return astOrderBy.reduce<number>((result, orderBy) => {\n      if (result !== 0) {\n        // We already found a way to sort these 2 documents, so there's\n        // no need to keep going. This doesn't actually break out of the\n        // reducer but prevents doing any further unnecessary and\n        // potentially expensive comparisons.\n        return result;\n      }\n\n      const field = orderBy.expr.column;\n\n      if (doc1[field] < doc2[field]) {\n        result = -1;\n      } else if (doc1[field] > doc2[field]) {\n        result = 1;\n      } else {\n        result = 0;\n      }\n\n      if (orderBy.type === 'DESC' && result !== 0) {\n        result = -result;\n      }\n\n      return result;\n    }, 0);\n  });\n}\n","import { assert, astValueToNative } from '../utils';\nimport { SQL_Value } from '../sql-parser';\n\nexport function applyLimit(\n  queries: firebase.firestore.Query[],\n  astLimit: SQL_Value\n): firebase.firestore.Query[] {\n  assert(\n    astLimit.type === 'number',\n    \"LIMIT has to be a number.\"\n  );\n  const limit = astValueToNative(astLimit) as number;\n  return queries.map(query => query.limit(limit));\n}\n\nexport function applyLimitLocally(\n  docs: firebase.firestore.DocumentData[],\n  astLimit: SQL_Value\n): firebase.firestore.DocumentData[] {\n  const limit = astValueToNative(astLimit) as number;\n  docs.splice(limit);\n  return docs;\n}\n","import firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { FireSQLOptions, QueryOptions } from './shared';\nimport { parse } from './sql-parser';\nimport { DocumentData, assert } from './utils';\nimport { select_ } from './select';\n\nexport class FireSQL {\n  private _ref: firebase.firestore.DocumentReference;\n\n  constructor(ref: FirestoreOrDocument, private _options: FireSQLOptions = {}) {\n    /*\n       We initially used `instanceof` to determine the object type, but that\n       only allowed using the client SDK. Doing it this way we can support\n       both the client and the admin SDKs.\n       */\n    if (typeof (ref as any).doc === 'function') {\n      // It's an instance of firebase.firestore.Firestore\n      try {\n        this._ref = (ref as firebase.firestore.Firestore).doc('/');\n      } catch (err) {\n        // If the Firestore instance we get is from the Admin SDK, it throws\n        // an error if we call `.doc(\"/\")` on it. In that case we just treat\n        // it as a firebase.firestore.DocumentReference\n        this._ref = ref as firebase.firestore.DocumentReference;\n      }\n    } else if (typeof (ref as any).collection === 'function') {\n      // It's an instance of firebase.firestore.DocumentReference\n      this._ref = ref as firebase.firestore.DocumentReference;\n    } else {\n      throw new Error(\n        'The first parameter needs to be a Firestore object ' +\n          ' or a Firestore document reference .'\n      );\n    }\n  }\n\n  get ref(): firebase.firestore.DocumentReference {\n    return this._ref;\n  }\n\n  get firestore(): firebase.firestore.Firestore {\n    return this._ref.firestore;\n  }\n\n  get options(): FireSQLOptions {\n    return this._options;\n  }\n\n  query(sql: string, options?: QueryOptions): Promise<DocumentData[]>;\n  query<T>(sql: string, options?: QueryOptions): Promise<T[]>;\n  async query<T>(\n    sql: string,\n    options: QueryOptions = {}\n  ): Promise<T[] | DocumentData[]> {\n    assert(\n      // tslint:disable-next-line: strict-type-predicates\n      typeof sql === 'string' && sql.length > 0,\n      'query() expects a non-empty string.'\n    );\n    const ast = parse(sql);\n\n    if (ast.type === 'select') {\n      return select_(this._ref, ast, { ...this._options, ...options });\n    } else {\n      throw new Error(\n        `\"${(ast.type as string).toUpperCase()}\" statements are not supported.`\n      );\n    }\n  }\n\n  toJSON(): object {\n    return {\n      ref: this._ref,\n      options: this._options\n    };\n  }\n}\n\nexport type FirestoreOrDocument =\n  | firebase.firestore.Firestore\n  | firebase.firestore.DocumentReference\n  | AdminFirestore\n  | AdminDocumentReference;\n\n/**\n * An interface representing the basics we need from the\n * admin.firestore.Firestore class.\n * We use it like this to avoid having to require \"firebase-admin\".\n */\ninterface AdminFirestore {\n  collection(collectionPath: string): any;\n  doc(documentPath: string): any;\n}\n\n/**\n * An interface representing the basics we need from the\n * admin.firestore.DocumentReference class.\n * We use it like this to avoid having to require \"firebase-admin\".\n */\ninterface AdminDocumentReference {\n  collection(collectionPath: string): any;\n  get(options?: any): Promise<any>;\n}\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\n// false -> Array#indexOf\n// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n// true  -> Array#includes\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","var toInteger = require('../internals/to-integer');\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","var toInteger = require('../internals/to-integer');\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('../internals/is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var isObject = require('../internals/is-object');\nvar document = require('../internals/global').document;\n// typeof document.createElement is 'object' in old IE\nvar exist = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return exist ? document.createElement(it) : {};\n};\n","var isObject = require('../internals/is-object');\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n","import { Observable, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { collectionData } from 'rxfire/firestore';\nimport { parse, SQL_Select } from '../sql-parser';\nimport { FireSQL } from '../firesql';\nimport { SelectOperation } from '../select';\nimport { assert, DocumentData, contains, DOCUMENT_KEY_NAME } from '../utils';\nimport { QueryOptions } from '../shared';\n\ndeclare module '../firesql' {\n  interface FireSQL {\n    rxQuery(sql: string, options?: QueryOptions): Observable<DocumentData[]>;\n    rxQuery<T>(sql: string, options?: QueryOptions): Observable<T[]>;\n  }\n}\n\nFireSQL.prototype.rxQuery = function<T>(\n  sql: string,\n  options?: QueryOptions\n): Observable<T[] | DocumentData[]> {\n  assert(\n    // tslint:disable-next-line: strict-type-predicates\n    typeof sql === 'string' && sql.length > 0,\n    'rxQuery() expects a non-empty string.'\n  );\n  const ast = parse(sql);\n  assert(ast.type === 'select', 'Only SELECT statements are supported.');\n  return rxSelect((this as any)._ref, ast, {\n    ...(this as any)._options,\n    ...options\n  });\n};\n\nfunction rxSelect(\n  ref: firebase.firestore.DocumentReference,\n  ast: SQL_Select,\n  options: QueryOptions\n): Observable<firebase.firestore.DocumentData[]> {\n  const selectOp = new SelectOperation(ref, ast, options);\n  let queries = selectOp.generateQueries_();\n\n  if (ast._next) {\n    assert(\n      ast._next.type === 'select',\n      ' UNION statements are only supported between SELECTs.'\n    );\n    // This is the UNION of 2 SELECTs, so lets process the second\n    // one and merge their queries\n    queries = queries.concat(selectOp.generateQueries_(ast._next));\n\n    // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\n    // SELECT only, instead of to the whole UNION. Find a workaround.\n  }\n\n  let idField: string;\n  let keepIdField: boolean;\n\n  if (selectOp._includeId === true) {\n    idField = DOCUMENT_KEY_NAME;\n    keepIdField = true;\n  } else if (typeof selectOp._includeId === 'string') {\n    idField = selectOp._includeId;\n    keepIdField = true;\n  } else {\n    idField = DOCUMENT_KEY_NAME;\n    keepIdField = false;\n  }\n\n  const rxData = combineLatest(\n    queries.map(query =>\n      collectionData<firebase.firestore.DocumentData>(query, idField)\n    )\n  );\n\n  return rxData.pipe(\n    map((results: firebase.firestore.DocumentData[][]) => {\n      // We have an array of results (one for each query we generated) where\n      // each element is an array of documents. We need to flatten them.\n      const documents: firebase.firestore.DocumentData[] = [];\n      const seenDocuments: { [id: string]: true } = {};\n\n      for (const docs of results) {\n        for (const doc of docs) {\n          // Note: for now we're only allowing to query a single collection, but\n          // if at any point we change that (for example with JOINs) we'll need to\n          // use the full document path here instead of just its ID\n          if (!contains(seenDocuments, doc[idField])) {\n            seenDocuments[doc[idField]] = true;\n            if (!keepIdField) {\n              delete doc[idField];\n            }\n            documents.push(doc);\n          }\n        }\n      }\n\n      return documents;\n    }),\n    map((documents: firebase.firestore.DocumentData[]) => {\n      return selectOp.processDocuments_(queries, documents);\n    })\n  );\n}\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\nvar split = ''.split;\n\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports = typeof window == 'object' && window && window.Math == Math ? window\n  : typeof self == 'object' && self && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('../internals/fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","'use strict';\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = nativeGetOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = nativeGetOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('../internals/descriptors') && !require('../internals/fails')(function () {\n  return Object.defineProperty(require('../internals/document-create-element')('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPrimitive = require('../internals/to-primitive');\nvar has = require('../internals/has');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPrimitive = require('../internals/to-primitive');\nvar nativeDefineProperty = Object.defineProperty;\n\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = require('../internals/descriptors') ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var global = require('../internals/global');\nvar hide = require('../internals/hide');\n\nmodule.exports = function (key, value) {\n  try {\n    hide(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + postfix).toString(36));\n};\n","var shared = require('../internals/shared')('keys');\nvar uid = require('../internals/uid');\n\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar isObject = require('../internals/is-object');\nvar hide = require('../internals/hide');\nvar objectHas = require('../internals/has');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar WeakMap = require('../internals/global').WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    hide(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.0.1',\n  mode: require('../internals/is-pure') ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n","module.exports = require('../internals/shared')('native-function-to-string', Function.toString);\n","var nativeFunctionToString = require('../internals/function-to-string');\nvar WeakMap = require('../internals/global').WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));\n","module.exports = {};\n","var has = require('../internals/has');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar arrayIndexOf = require('../internals/array-includes')(false);\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","var has = require('../internals/has');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var fails = require('../internals/fails');\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar hide = require('../internals/hide');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      hide(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('../internals/an-object');\nvar defineProperties = require('../internals/object-define-properties');\nvar enumBugKeys = require('../internals/enum-bug-keys');\nvar html = require('../internals/html');\nvar documentCreateElement = require('../internals/document-create-element');\nvar IE_PROTO = require('../internals/shared-key')('IE_PROTO');\nvar PROTOTYPE = 'prototype';\nvar Empty = function () { /* empty */ };\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var length = enumBugKeys.length;\n  var lt = '<';\n  var script = 'script';\n  var gt = '>';\n  var js = 'java' + script + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  iframe.src = String(js);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\nrequire('../internals/hidden-keys')[IE_PROTO] = true;\n","var global = require('../internals/global');\nvar hide = require('../internals/hide');\nvar has = require('../internals/has');\nvar setGlobal = require('../internals/set-global');\nvar nativeFunctionToString = require('../internals/function-to-string');\nvar InternalStateModule = require('../internals/internal-state');\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(nativeFunctionToString).split('toString');\n\nrequire('../internals/shared')('inspectSource', function (it) {\n  return nativeFunctionToString.call(it);\n});\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else hide(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);\n});\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar internalObjectKeys = require('../internals/object-keys-internal');\nvar hiddenKeys = require('../internals/enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\nvar Reflect = require('../internals/global').Reflect;\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","// Chrome 38 Symbol has incorrect toString conversion\nmodule.exports = !require('../internals/fails')(function () {\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n","var store = require('../internals/shared')('wks');\nvar uid = require('../internals/uid');\nvar Symbol = require('../internals/global').Symbol;\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = function (name) {\n  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]\n    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar anObject = require('../internals/an-object');\nvar objectKeys = require('../internals/object-keys');\n\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var key;\n  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);\n  return O;\n};\n","var document = require('../internals/global').document;\n\nmodule.exports = document && document.documentElement;\n","var UNSCOPABLES = require('../internals/well-known-symbol')('unscopables');\nvar create = require('../internals/object-create');\nvar hide = require('../internals/hide');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  hide(ArrayPrototype, UNSCOPABLES, create(null));\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n","var aFunction = require('../internals/a-function');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","'use strict';\nvar internalIncludes = require('../internals/array-includes')(true);\n\n// `Array.prototype.includes` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\nrequire('../internals/export')({ target: 'Array', proto: true }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return internalIncludes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\nrequire('../internals/add-to-unscopables')('includes');\n","var global = require('../internals/global');\nvar bind = require('../internals/bind-context');\nvar call = Function.call;\n\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n","module.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n","// `Number.isNaN` method\n// https://tc39.github.io/ecma262/#sec-number.isnan\nrequire('../internals/export')({ target: 'Number', stat: true }, {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n","module.exports = require('../internals/global');\n","require('../../modules/es.number.is-nan');\n\nmodule.exports = require('../../internals/path').Number.isNaN;\n"],"names":["child","parent","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","C","constructor","input","options","undefined","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","peg$c1","peg$c2","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c33","peg$c34","peg$c35","peg$c37","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$r0","peg$r1","peg$r2","peg$r3","peg$r4","peg$r6","peg$r7","peg$r8","peg$r9","peg$r10","peg$r11","peg$e0","peg$literalExpectation","peg$e1","peg$e2","peg$otherExpectation","peg$e3","peg$e4","peg$e5","peg$e6","peg$e7","peg$e8","peg$e9","peg$e10","peg$e11","peg$e12","peg$e13","peg$e14","peg$e15","peg$e16","peg$e17","peg$classExpectation","peg$e18","peg$e19","peg$e20","peg$e21","peg$e22","peg$e23","peg$e24","peg$e25","peg$e26","peg$e27","peg$e28","peg$e29","peg$e30","peg$e31","peg$e32","peg$e33","peg$e34","peg$e35","peg$e36","peg$e37","peg$e38","peg$e39","peg$e40","peg$e41","peg$e42","peg$e43","peg$e44","peg$e45","peg$e46","peg$e47","peg$e48","peg$e49","peg$e50","peg$e51","peg$e52","peg$e53","peg$e54","peg$e55","peg$e56","peg$e57","peg$e58","peg$e59","peg$e60","peg$e61","peg$e62","peg$e63","peg$e64","peg$e65","peg$e66","peg$e67","peg$e68","peg$f0","ast","peg$f1","head","tail","cur","i","length","_next","peg$f2","s","peg$f3","d","c","f","w","g","o","l","type","distinct","columns","from","where","groupby","orderby","limit","peg$f4","peg$f5","createList","peg$f6","e","alias","expr","as","peg$f7","peg$f8","peg$f9","group","t","db","parts","Array","isArray","peg$f10","dt","map","peg$f11","peg$f12","obj","peg$f13","lim","peg$f14","el","value","room","ep","epList","exprList","push","createExprList","peg$f15","createBinaryExprChain","peg$f16","operator","peg$f17","left","rh","createBinaryExpr","op","right","peg$f18","peg$f19","peg$f20","begin","end","peg$f21","nk","peg$f22","peg$f23","peg$f24","paren","peg$f25","tbl","col","table","column","peg$f26","peg$f27","reservedMap","toUpperCase","peg$f28","peg$f29","chars","join","peg$f30","peg$f31","field","peg$f32","peg$f34","peg$f35","peg$f36","peg$f37","ca","peg$f38","peg$f39","peg$f40","peg$f41","peg$f42","peg$f43","peg$f44","peg$f45","peg$f46","peg$f47","h1","h2","h3","h4","String","fromCharCode","parseInt","peg$f48","n","peg$f49","peg$f50","int_","frac","exp","x","parseFloat","toString","peg$f51","peg$f52","peg$f53","peg$f54","digit19","digits","peg$f55","peg$f56","digit","peg$f57","peg$f58","peg$f59","peg$f60","sign","peg$f61","peg$f62","peg$f63","peg$f64","peg$f65","peg$f66","peg$f67","peg$f68","peg$f69","peg$f70","peg$f71","peg$f72","peg$f74","peg$f75","peg$f76","peg$f77","peg$currPos","peg$posDetailsCache","line","peg$expected","peg$silentFails","startRule","text","ignoreCase","inverted","description","peg$computePosDetails","pos","p","details","charCodeAt","peg$VALIDFILENAME","filename","peg$computeLocation","startPos","endPos","loc","startPosDetails","offset","endPosDetails","peg$begin","variants","peg$expect","top","peg$end","invert","pop","prototype","apply","s0","s2","peg$parse__","s1","s3","s4","s5","s6","s7","peg$parseselect_stmt","peg$parseKW_UNION","peg$parseunion_stmt","rule$expects","s9","s11","s13","s15","substr","toLowerCase","peg$parseident_start","peg$parsecolumn_list_item","peg$parseCOMMA","peg$parsecolumn_clause","peg$parseKW_GROUP","peg$parsetable_name","peg$parseKW_AS","peg$parseident","peg$parseor_expr","peg$parseKW_BY","peg$parsecolumn_ref","peg$parsecolumn_ref_list","peg$parseorder_by_element","peg$parseorder_by_list","peg$parseint","peg$parseadditive_expr","peg$parseident_name","peg$parseand_expr","peg$parseKW_OR","peg$parsenot_expr","peg$parseKW_AND","peg$parseKW_NOT","peg$parsecomparison_expr","peg$parsearithmetic_comparison_operator","peg$parsearithmetic_op_right","peg$parseKW_IN","peg$parseLPAREN","peg$parseexpr_list","peg$parseRPAREN","peg$parseKW_LIKE","peg$parseKW_CONTAINS","peg$parseliteral","peg$parsemultiplicative_expr","peg$parseadditive_operator","peg$parseprimary","peg$parsemultiplicative_operator","peg$parsecolumn","test","charAt","peg$parseident_part","peg$parsedouble_char","peg$parsesingle_char","peg$parseliteral_string","peg$parsefrac","peg$parseexp","peg$parseescape_char","peg$parsehexDigit","peg$parsedigit19","peg$parsedigits","peg$parsedigit","peg$parsewhitespace","result","failPos","SHOW","DROP","SELECT","UPDATE","CREATE","DELETE","INSERT","REPLACE","EXPLAIN","ALL","DISTINCT","AS","TABLE","INTO","FROM","SET","LEFT","ON","INNER","JOIN","UNION","VALUES","EXISTS","WHERE","GROUP","BY","HAVING","ORDER","ASC","DESC","LIMIT","BETWEEN","IN","IS","LIKE","CONTAINS","NOT","AND","OR","TRUE","FALSE","NULL","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","class","escapedParts","part","classEscape","any","other","not","describeExpectation","hex","ch","replace","j","descriptions","sort","slice","describeExpected","DOCUMENT_KEY_NAME","assert","condition","contains","prop","Object","hasOwnProperty","call","safeGet","astValueToNative","astValue","Number","nameOrAlias","aggrFn","key","sum","avg","min","max","total","applyCondition","queries","astOperator","negValue","value_1","operator_1","newOp","whereFilterOp","query","stringASTWhereValue","str","VALID_AGGR_FUNCTIONS","SelectOperation","_ast","path","_ref","firestore","collectionGroup","collection","applyWhere","astWhere","newQueries_1","forEach","valueObj","whereLike","strLength","endsWith","substring","beginsWith","equals","successorStr","prefix","index","prefixSuccessor","includes","orderBy","astLimit","applyLimit","concat","generateQueries_","documents","seenDocuments","Promise","all","get","snapshot","_a","numDocs","docs","docSnap","docPath","ref","docData","data","_includeId","id","groupedDocs","astGroupBy","DocumentsGroup","groupBy","applySingleGroupBy","doc","groupValue","keys","applyGroupByLocally","_processGroupedDocs","_processUngroupedDocs","astOrderBy","doc1","doc2","reduce","splice","aggrColumns","getAggrColumns","docsGroup","aggregateDocuments","_buildResultEntry","aggr","_this","groups","flattenGroupedDocs","flatInner","innerProp","firstGroupKey","firstDoc","results_1","groupKey","resultEntry","document","aggregate","asFieldArray","idIncluded","resultFields","entries","fieldName","fieldAlias","AliasedField","split","some","vaidateAggrFunction","includeId","functions","skipSum","fn","isNumber","isNaN","astColumn","FireSQL","_options","sql","parse","selectOp","executeQueries_","processDocuments_","select_","err","exec","error","it","IndexedObject","TypeError","requireObjectCoercible","argument","floor","ceil","IS_INCLUDES","$this","fromIndex","integer","O","toIndexedObject","toInteger","bitmap","enumerable","configurable","writable","S","isObject","val","valueOf","exist","createElement","rxQuery","idField","keepIdField","combineLatest","collectionData","pipe","results","_i","docs_1","fails","propertyIsEnumerable","Math","window","self","Function","require$$0","defineProperty","a","nativePropertyIsEnumerable","nativeGetOwnPropertyDescriptor","getOwnPropertyDescriptor","1","V","descriptor","require$$1","require$$2","DESCRIPTORS","P","toPrimitive","IE8_DOM_DEFINE","has","createPropertyDescriptor","propertyIsEnumerableModule","nativeDefineProperty","Attributes","anObject","object","definePropertyModule","hide","global","postfix","shared","uid","set","SHARED","store","setGlobal","module","version","mode","copyright","WeakMap","nativeFunctionToString","random","NATIVE_WEAK_MAP","wmget","wmhas","wmset","metadata","STATE","sharedKey","hiddenKeys","objectHas","names","arrayIndexOf","target","source","ownKeys","getOwnPropertyDescriptorModule","isForced","feature","detection","normalize","POLYFILL","NATIVE","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","noTargetGet","forced","copyConstructorProperties","sham","redefine","Empty","enforce","getterFor","TYPE","state","getInternalState","InternalStateModule","enforceInternalState","TEMPLATE","unsafe","simple","getOwnPropertyNames","internalObjectKeys","getOwnPropertySymbols","Reflect","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","replacement","string","Symbol","enumBugKeys","defineProperties","Properties","objectKeys","documentElement","IE_PROTO","PROTOTYPE","createDict","iframeDocument","iframe","documentCreateElement","style","display","html","appendChild","src","contentWindow","open","write","lt","close","F","create","UNSCOPABLES","NATIVE_SYMBOL","ArrayPrototype","internalIncludes","proto","arguments","aFunction","number"],"mappings":"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"}